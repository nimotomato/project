# project
#### Video Demo: <URL HERE>
#### Description:
This is a game created using the Python module Pygame. It is a canine twist on the classic snake. You maneuver your space dog with the arrowkeys. I've always loved to play games and I have fond memories of when I was a little kid, playing snake on some friend's father's Nokia. I used to create a bunch of Warcraft 3 maps as well as a kid, but that was like 15 years ago. Now, as the final project of CS50x was to be chosen, I finally decided on trying to make a game from scratch. I had to read a lot of documentation, watch a lot of instructional videos and hit Stack Overflow a lot. But, in the end, I'm quite pleased with the result!
  
Your objective is to catch as many bones as possible, avoid hitting yourself, avoid hitting walls and avoid eating too many chocolates.

There are four classes in the game: 
  The main driver, which handles the bulk of the operations. This is stuff like collisions, updating speed, drawing the graphics, executing the methods in the correct order, handling game over etc. 
  The "choco", which simply instantiates a chocolate object on a random position and draws it to the screen.
  The "bone", which does the same as choco but with a bone
  And the "dog", which draws the dog. The dog has four different parts, with different orientations that get drawn depending on their orientation. Orientation is determined with a true/false statement for the head, and using vectors for the tail, middle part and curved part. I use vectors because apparently they are easy to add together. Had I remade the project however, I think I just would have used tuples as I had to cast the vector into tuples anyway. 
  
There are also a lot of constants that make it easier to tweak the specifics of the game. Some of the things are not super important in my opinion, such as the number of bones spawned, the speed increment for the space dog (which makes the space dog go faster the more he eats) or the size of the chocolate amount. Naturally, these are necessary variables but they are mainly there for game balance. More important for hte structure of the game is the FPS which controls how often the screen is drawn. If the FPS is too high, computers may have different experiences because they are able to refresh with different speeds. Another really important constant is the MOV_TICKER, which is a variable containing an initialized user event in pygame. This, together with a timer that is set in the update_speed method of the DRIVER class, is what gives the game its "snakey" feel with updates that "tick". Otherwise, the space dog would move continuously and constantly update. Now, the loop is only allowed to update once every (STARTING_SPEED - (self.current_level * SPEED_INCREMENT).
  
Partly becayse of the "snakey" feel with updates that "tick", and partly because most sizes are used with constans BLOCK_SIZE and BLOCK_NUMBER, the game feels like a grid. This makes everything fit neatly into place and aligns everything correctly. However, it is really more of a "grid feel" than an acutal grid. There are some advantages with this in that it is slightly easier to implement. However, if I were to remake it, I would probably implement a grid class, where things could spawn into the grids. This would make it easier to avoid overlaps. For example, if a chocolate spawns on a bone, I solved it by moving the bone. With a grid class, I could just check if the box was occupied and then not spawn anything there which would be way more generalizable. 
  
Finally, the code ends with the main loop. While the loop runs, the game updates. If user wants to quit or reaches game over, the loop ends and the program exits the game. Within the main loop the FPS is set with clock.tick(FPS), which is 60. Apparently, 60 is a good number to set FPS at. There are also events being handled. The first of them is the QUIT event, which allows the player to easily exit the program. Next is the MOV_TICKER, explained above. Again, it is like a gate keeper that prevents the driver to update too frequently, which gives the game a "snakey" feel. Finally, we have the controls. If key is pressed, the vector of the dog is changed as well as the head orientation, which allows the rest of the body to "follow" from the DOG class. Finally, the loop ends with drawing the window and then updating it. Drawing the window does not automatically refresh the display, so both methods are needed. I suppose the refreshing could be written in the draw_window method, but this way it gives me more control.
